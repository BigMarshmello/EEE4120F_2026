% GROUP NUMBER:
%
% MEMBERS:
%   - Alex Hillman, HLLALE010
%   - Joab Kloppers, KLPJOA002

function run_analysis()
    % TODO1:
    % Load all the sample images from the 'sample_images' folder
    image = imread('sample_images/image_128x128.png');
    disp(size(image));
    image = rgb2gray(image);
    
    % TODO2:
    % Define edge detection kernels (Sobel kernel)
    Gx = [-1 0 1; -2 0 2; -1 0 1];
    Gy = [-1 -2 -1; 0 0 0; 1 2 1];
    
    % TODO3:
    % For each image, perform the following:
    %   a. Measure execution time of my_conv2
    %   b. Measure execution time of inbuilt_conv2
    %   c. Compute speedup ratio
    %   d. Verify output correctness (compare results)
    %   e. Store results (image name, time_manual, time_builtin, speedup)
    %   f. Plot and compare results
    %   g. Visualise the edge detection results(Optional)
    [result, elapsed_time] = inbuilt_conv2(image, Gx, Gy, 'same');

    tic
    result_manual = my_conv2(image,Gx,Gy, 'full');
    elapsed_time_manual =toc;

    

    fprintf('Elapsed Time for Inbuilt: %.6f\n', elapsed_time);
    fprintf('Elapsed Time for Manual: %.6f\n', elapsed_time_manual);
    
    [Inbuilt_Size_x,Inbuilt_Size_y] = size(result);
    [Manual_Size_x,Manual_Size_y] = size(result_manual);

    fprintf("Returend Image Size for Inbuilt: %i X %i\n", Inbuilt_Size_x,Inbuilt_Size_y);
    fprintf("Returend Image Size for Manual: %i X %i\n", Manual_Size_x,Manual_Size_y);

    figure;
    subplot(1,3,1); imshow(image); title('Original');
    subplot(1,3,2); imshow(result, []); title('Edge Detection');
    subplot(1,3,3); imshow(result_manual, []); title('Edge Detection 2');
    imshow(result, []);
    
    
    
end
%% ========================================================================
%  PART 1: Manual 2D Convolution Implementation
%  ==
% TODO: Use conv2 to perform 2D convolution
% output - Convolved image result (grayscale)
function [result, elapsed_time] = inbuilt_conv2(image, Gx, Gy, padding)%Add necessary input arguments

image = double(image);
tic
Gx_result = conv2(image, Gx, padding);
Gy_result = conv2(image, Gy, padding);
result = sqrt(Gx_result.^2 + Gy_result.^2);

elapsed_time = toc;

end


% TODO: Implement manual 2D convolution using Sobel Operator(Gx and Gy)
% output - Convolved image result (grayscale)

function Result = my_conv2(image, kernelx, kernely, padding="same") %Add necessary input arguments
    
    function output = convolve2d(image,kernel,padding) %function to perform the individual convolve
        image = double(image); %convert values to doubles
        
        [rows, cols] = size(image);
        [k_rows, k_cols] = size(kernel);
    
        switch padding %different cases for the different padding options
            case "full"
                pad = k_rows-1; %get the required pad amount
                patch_Size = floor(k_rows/2); % get the patch offset value
                image_padded = padarray(image, [pad pad], 0,"both"); %get the padded image
    
                starting = ceil(k_rows/2); %get the starting and ending values for the loops
                ending = floor(k_rows/2);
            
                [padRows,padCols] = size(image_padded);
                output = zeros(rows+2, cols+2); %define the output matrix
                
                for i = starting:padRows-ending
                    for j = starting:padCols-ending
                        patch = image_padded(i-patch_Size:i+patch_Size,j-patch_Size:j+patch_Size);
                        output(i-1,j-1) = sum(sum(patch .* kernel)); %get the colvolution for each pixel
                    end 
                end
    
            case "same"
                pad = floor(k_rows/2);   %get required padding
                starting = ceil(k_rows/2); %get starting value for loops
                image_padded = padarray(image, [pad pad], 0,"both"); %pad the image with required 0s
            
                [padRows,padCols] = size(image_padded);
                output = zeros(rows, cols); %define the output matrix
                
                for i = starting:padRows-pad 
                    for j = starting:padCols-pad
                        patch = image_padded(i-pad:i+pad,j-pad:j+pad);
                        output(i-1,j-1) = sum(sum(patch .* kernel)); %get convolution for each pixel
                    end 
                end
    
            case "valid"
                patch_size = floor(k_rows/2);  %get offset value for patch
            
                [rows,cols] = size(image);
                output = zeros(rows-2, cols-2); %define output matrix
                
                for i = 2:rows-1 
                    for j = 2:cols-1
                        patch = image(i-patch_size:i+patch_size,j-patch_size:j+patch_size);
                        output(i-1,j-1) = sum(sum(patch .* kernel)); %get convolution for each pixel
                    end 
                end
        end
    end

    Gx = convolve2d(image,kernelx,padding); %use local
    Gy = convolve2d(image,kernely,padding);
    Result = sqrt (Gy.^2+ Gx.^2);

end
